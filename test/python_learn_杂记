http://www.cnblogs.com/yuanchenqi/articles/7487059.html
Django_Form补充勾子函数验证

随机验证码：
http://www.cnblogs.com/yuanchenqi/articles/7468816.html
验证码基码参见random模块：http://www.digmyth.com/2017/02/20/python-05-02-模块

Django 认证系统
http://www.cnblogs.com/yuanchenqi/articles/7609586.html
from django.contrib import auth  #
user=auth.authenticate(usernamme=username,password=username)：
if user:
    验证通过
else:
   error="用户名或密码错误"


{{ request.user  }}  这个变量不需要传入前端，当使用Django auth模块时可以直接在前端直接使用 
AnonymousUser
wxq

<a href="/logout/">注销<a/> 	

auth.lougout(request)   # 底层也是调用request.session.flush()
return redirect("/login/")

request.user.is_authenticated()   # 表明用户有session,能通过验证


利用Django自带的表创建用户，不能对Django自带的表直接操作，那怎么创建呢，Django提供一个接口，通过auth模块操作User表.
from django.contrib.auth.models import User
user = User.objects.create_user（username='',password='',email=''）
当Django自带User表字段不够用时，可以自己建表继承User表字段，方法:
from django.contrib.auth.models import  AbstractUser
class UserInfo(AbstractUser):
     detail = modoles.CharField(max_length=32)


$("#span").html(data)  # span标签赋值  <span id="span">spantest</span>
  
input框赋值 <p><input id="ret" type="text" name="xx"/></p>
$("#ret").val(data)

ajax error_msg

$("#login_error").html(error_msg).css("color","red");    # <>add XX</>  # 写入内容并变红

setTimeout(function (){
           $("#login_error").html("")                    # <>rm XX</>   # 清空内容
}，3000)  # 3秒钟后执行函数



onload="successBack();" # 一个标签内容有更新时重新加载
function successBack(){...};


form id='ff1'
<button onclck="change">提交</button>
function change(){
    document.getElementById('ff1').submit();
}




